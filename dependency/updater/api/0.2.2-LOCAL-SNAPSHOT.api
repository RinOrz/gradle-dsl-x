// Signature format: 4.0
package de.fayard.refreshVersions {

  public class FeatureFlagExtension {
    ctor public FeatureFlagExtension();
    method public final void disable(de.fayard.refreshVersions.core.FeatureFlag flag);
    method public final void enable(de.fayard.refreshVersions.core.FeatureFlag flag);
  }

  public class RefreshVersionsDependenciesMigrationTask extends org.gradle.api.DefaultTask {
    ctor public RefreshVersionsDependenciesMigrationTask();
    method @org.gradle.api.tasks.TaskAction public final void taskActionMigrate();
  }

  public class RefreshVersionsExtension {
    ctor public RefreshVersionsExtension();
    method @org.gradle.api.Incubating public final void enableBuildSrcLibs();
    method public final void extraArtifactVersionKeyRules(error.NonExistentClass file);
    method public final void extraArtifactVersionKeyRules(String rawRules);
    method public final void featureFlags(org.gradle.api.Action<de.fayard.refreshVersions.FeatureFlagExtension> extension);
    method public final java.util.List<java.lang.String> getExtraArtifactVersionKeyRules();
    method public final error.NonExistentClass! getVersionsPropertiesFile();
    method public final void rejectVersionIf(groovy.lang.Closure<java.lang.Boolean> filter);
    method public final void rejectVersionIf(kotlin.jvm.functions.Function1<? super de.fayard.refreshVersions.core.DependencySelection,java.lang.Boolean> filter);
    method public final void setExtraArtifactVersionKeyRules(java.util.List<java.lang.String> extraArtifactVersionKeyRules);
    method public final void setVersionsPropertiesFile(error.NonExistentClass! versionsPropertiesFile);
    property public final java.util.List<java.lang.String> extraArtifactVersionKeyRules;
    property public final error.NonExistentClass! versionsPropertiesFile;
  }

  public class RefreshVersionsMigrateTask extends org.gradle.api.DefaultTask {
    ctor public RefreshVersionsMigrateTask();
    method @org.gradle.api.tasks.TaskAction public final void migrateBuild();
    method @org.gradle.api.tasks.TaskAction public final void refreshVersionsMissingEntries();
  }

  public final class RefreshVersionsMigrateTaskKt {
  }

  public final class RefreshVersionsMigration {
    method public static void migrateIfNeeded(org.gradle.api.initialization.Settings, String fromVersion);
  }

  public class RefreshVersionsPlugin implements org.gradle.api.Plugin<java.lang.Object> {
    ctor public RefreshVersionsPlugin();
    method public void apply(Object target);
    method public static final java.util.List<java.lang.String> getArtifactVersionKeyRules();
    field public static final de.fayard.refreshVersions.RefreshVersionsPlugin.Companion Companion;
  }

  public static final class RefreshVersionsPlugin.Companion {
    method public java.util.List<java.lang.String> getArtifactVersionKeyRules();
    property public final java.util.List<java.lang.String> artifactVersionKeyRules;
  }

  public final class RefreshVersionsSetup {
    method public static void bootstrap(org.gradle.api.initialization.Settings, optional error.NonExistentClass versionsPropertiesFile);
    method public static void bootstrap(org.gradle.api.initialization.Settings);
    method public static void bootstrapForBuildSrc(org.gradle.api.initialization.Settings);
  }

}

package de.fayard.refreshVersions.core {

  public abstract sealed class AbstractDependencyGroup {
    method public final String getGroup();
    method public final boolean getUsePlatformConstraints();
    method public final de.fayard.refreshVersions.core.DependencyNotation module(String name, optional boolean isBom, optional Boolean? usePlatformConstraints);
    method @de.fayard.refreshVersions.core.internal.InternalRefreshVersionsApi public final void reset();
    method public final void setUsePlatformConstraints(boolean usePlatformConstraints);
    property public final String group;
    property public final boolean usePlatformConstraints;
    field public static final de.fayard.refreshVersions.core.AbstractDependencyGroup.Companion Companion;
  }

  public static final class AbstractDependencyGroup.Companion {
    method public java.util.List<de.fayard.refreshVersions.core.internal.ArtifactVersionKeyRule> getALL_RULES();
    method public boolean getDisableBomCheck();
    method public void setDisableBomCheck(boolean disableBomCheck);
    property public final java.util.List<de.fayard.refreshVersions.core.internal.ArtifactVersionKeyRule> ALL_RULES;
    property public final boolean disableBomCheck;
  }

  public interface DependencyNotation {
    method public default void attachToGroup(de.fayard.refreshVersions.core.AbstractDependencyGroup dependencyGroup);
    method public Void getExternalImplementationGuard();
    method public operator String invoke(String? version);
    method public String toString();
    method public String withVersion(String version);
    method public String withVersionPlaceholder();
    method public String withoutVersion();
    property public abstract Void externalImplementationGuard;
    field public static final de.fayard.refreshVersions.core.DependencyNotation.Companion Companion;
  }

  public static final class DependencyNotation.Companion {
    method public operator de.fayard.refreshVersions.core.DependencyNotation invoke(String group, String name, optional boolean isBom, optional Boolean? usePlatformConstraints);
  }

  public final class DependencySelection {
    method public de.fayard.refreshVersions.core.Version getCandidate();
    method public de.fayard.refreshVersions.core.Version getCurrent();
    method public de.fayard.refreshVersions.core.ModuleId getModuleId();
    method public String getVersionKey();
    property public final de.fayard.refreshVersions.core.Version candidate;
    property public final de.fayard.refreshVersions.core.Version current;
    property public final de.fayard.refreshVersions.core.ModuleId moduleId;
    property public final String versionKey;
    field public de.fayard.refreshVersions.core.Version candidate;
  }

  @org.gradle.api.Incubating public abstract class DependencyVersionsFetcher {
    ctor protected DependencyVersionsFetcher(de.fayard.refreshVersions.core.ModuleId moduleId, Object repoKey);
    method public final boolean equals(Object? other);
    method @kotlin.jvm.Throws(exceptionClasses={IOException::class, Exception::class}) public abstract suspend Object? getAvailableVersionsOrNull(kotlin.jvm.functions.Function1<? super de.fayard.refreshVersions.core.Version,java.lang.Boolean>? versionFilter, kotlin.coroutines.Continuation<? super de.fayard.refreshVersions.core.DependencyVersionsFetcher.SuccessfulResult> p);
    method public final de.fayard.refreshVersions.core.ModuleId getModuleId();
    method public final Object getRepoKey();
    method public final int hashCode();
    property public final de.fayard.refreshVersions.core.ModuleId moduleId;
    property public final Object repoKey;
    field public static final de.fayard.refreshVersions.core.DependencyVersionsFetcher.Companion Companion;
  }

  public static final class DependencyVersionsFetcher.Companion {
  }

  public static final class DependencyVersionsFetcher.SuccessfulResult {
    ctor public DependencyVersionsFetcher.SuccessfulResult(long lastUpdateTimestampMillis, java.util.List<de.fayard.refreshVersions.core.Version> availableVersions);
    method public long component1();
    method public java.util.List<de.fayard.refreshVersions.core.Version> component2();
    method public de.fayard.refreshVersions.core.DependencyVersionsFetcher.SuccessfulResult copy(long lastUpdateTimestampMillis, java.util.List<de.fayard.refreshVersions.core.Version> availableVersions);
    method public boolean equals(Object? other);
    method public java.util.List<de.fayard.refreshVersions.core.Version> getAvailableVersions();
    method public long getLastUpdateTimestampMillis();
    method public int hashCode();
    method public String toString();
    property public final java.util.List<de.fayard.refreshVersions.core.Version> availableVersions;
    property public final long lastUpdateTimestampMillis;
  }

  public enum FeatureFlag {
    enum_constant public static final de.fayard.refreshVersions.core.FeatureFlag GRADLE_UPDATES;
    enum_constant public static final de.fayard.refreshVersions.core.FeatureFlag LIBS;
    field public static final de.fayard.refreshVersions.core.FeatureFlag.Companion Companion;
  }

  public static final class FeatureFlag.Companion {
    method public java.util.Map<de.fayard.refreshVersions.core.FeatureFlag,java.lang.Boolean> getUserSettings();
    property public final java.util.Map<de.fayard.refreshVersions.core.FeatureFlag,java.lang.Boolean> userSettings;
  }

  @org.gradle.api.Incubating public class MissingEntriesTask extends org.gradle.api.DefaultTask {
    ctor public MissingEntriesTask();
    method @org.gradle.api.tasks.TaskAction public final void refreshVersionsMissingEntries();
  }

  public final class MissingEntriesTaskKt {
    method @de.fayard.refreshVersions.core.internal.InternalRefreshVersionsApi public static void addMissingEntriesInVersionsProperties(org.gradle.api.Project project);
    method @de.fayard.refreshVersions.core.internal.InternalRefreshVersionsApi public static int countDependenciesWithHardcodedVersions(org.gradle.api.artifacts.Configuration, java.util.Map<java.lang.String,java.lang.String> versionsMap, de.fayard.refreshVersions.core.internal.ArtifactVersionKeyReader versionKeyReader);
    method @de.fayard.refreshVersions.core.internal.InternalRefreshVersionsApi public static int countDependenciesWithHardcodedVersions(org.gradle.api.Project, java.util.Map<java.lang.String,java.lang.String> versionsMap);
    method @de.fayard.refreshVersions.core.internal.InternalRefreshVersionsApi public static boolean shouldBeIgnored(org.gradle.api.artifacts.Configuration);
  }

  @org.gradle.api.Incubating public final class ModuleId {
    ctor public ModuleId(String? group, String name);
    method public String? component1();
    method public String component2();
    method public de.fayard.refreshVersions.core.ModuleId copy(String? group, String name);
    method public boolean equals(Object? other);
    method public String? getGroup();
    method public String getName();
    method public int hashCode();
    method public String toString();
    property public final String? group;
    property public final String name;
  }

  public class RefreshVersionsCleanupTask extends org.gradle.api.DefaultTask {
    ctor public RefreshVersionsCleanupTask();
    method @org.gradle.api.tasks.TaskAction public final void cleanUpSettings();
    method @org.gradle.api.tasks.TaskAction public final void cleanUpVersionsProperties();
  }

  public class RefreshVersionsCorePlugin implements org.gradle.api.Plugin<org.gradle.api.Project> {
    ctor public RefreshVersionsCorePlugin();
    method public void apply(org.gradle.api.Project project);
    field public static final de.fayard.refreshVersions.core.RefreshVersionsCorePlugin.Companion Companion;
  }

  @de.fayard.refreshVersions.core.internal.InternalRefreshVersionsApi public static final class RefreshVersionsCorePlugin.Companion {
    method public error.NonExistentClass! getCurrentVersion();
    property public final error.NonExistentClass! currentVersion;
  }

  @de.fayard.refreshVersions.core.internal.InternalRefreshVersionsApi public static final class RefreshVersionsCorePlugin.LogMarkers {
    field public static final de.fayard.refreshVersions.core.RefreshVersionsCorePlugin.LogMarkers INSTANCE;
    field public static final org.slf4j.Marker default;
  }

  public final class RefreshVersionsCoreSetup {
    method public static void bootstrap(org.gradle.api.initialization.Settings, optional java.util.List<java.lang.String> artifactVersionKeyRules, optional error.NonExistentClass versionsPropertiesFile);
    method public static void bootstrap(org.gradle.api.initialization.Settings, optional java.util.List<java.lang.String> artifactVersionKeyRules);
    method public static void bootstrap(org.gradle.api.initialization.Settings);
    method public static void bootstrapForBuildSrc(org.gradle.api.initialization.Settings);
  }

  public class RefreshVersionsTask extends org.gradle.api.DefaultTask {
    ctor public RefreshVersionsTask();
    method public final de.fayard.refreshVersions.core.FeatureFlag? getDisableFlag();
    method public final de.fayard.refreshVersions.core.FeatureFlag? getEnableFlag();
    method public final void setDisableFlag(de.fayard.refreshVersions.core.FeatureFlag? value);
    method public final void setEnableFlag(de.fayard.refreshVersions.core.FeatureFlag? value);
    method @org.gradle.api.tasks.TaskAction public final void taskActionRefreshVersions();
    property public final de.fayard.refreshVersions.core.FeatureFlag? disableFlag;
    property public final de.fayard.refreshVersions.core.FeatureFlag? enableFlag;
  }

  @org.gradle.api.Incubating public enum StabilityLevel {
    method public final infix boolean isAtLeastAsStableAs(de.fayard.refreshVersions.core.StabilityLevel other);
    method public final infix boolean isLessStableThan(de.fayard.refreshVersions.core.StabilityLevel other);
    method public final infix boolean isMoreStableThan(de.fayard.refreshVersions.core.StabilityLevel other);
    enum_constant public static final de.fayard.refreshVersions.core.StabilityLevel Alpha;
    enum_constant public static final de.fayard.refreshVersions.core.StabilityLevel Beta;
    enum_constant public static final de.fayard.refreshVersions.core.StabilityLevel Development;
    enum_constant public static final de.fayard.refreshVersions.core.StabilityLevel EarlyAccessProgram;
    enum_constant public static final de.fayard.refreshVersions.core.StabilityLevel Milestone;
    enum_constant public static final de.fayard.refreshVersions.core.StabilityLevel Preview;
    enum_constant public static final de.fayard.refreshVersions.core.StabilityLevel ReleaseCandidate;
    enum_constant public static final de.fayard.refreshVersions.core.StabilityLevel Snapshot;
    enum_constant public static final de.fayard.refreshVersions.core.StabilityLevel Stable;
    enum_constant public static final de.fayard.refreshVersions.core.StabilityLevel Unknown;
  }

  @org.gradle.api.Incubating public final class Version {
    ctor public Version(String value);
    method public int compareTo(de.fayard.refreshVersions.core.Version other);
    method public String component1();
    method public de.fayard.refreshVersions.core.Version copy(String value);
    method public boolean equals(Object? other);
    method public de.fayard.refreshVersions.core.StabilityLevel getStabilityLevel();
    method public String getValue();
    method public int hashCode();
    method public String toString();
    property public final de.fayard.refreshVersions.core.StabilityLevel stabilityLevel;
    property public final String value;
    field public static final de.fayard.refreshVersions.core.Version.Companion Companion;
  }

  public static final class Version.Companion {
  }

  public final class Versions {
    method public static String versionFor(String versionKey);
    method public static String versionFor(CharSequence dependencyNotation);
  }

}

package de.fayard.refreshVersions.core.extensions.collections {

  public final class MutableListKt {
  }

}

package de.fayard.refreshVersions.core.extensions.dom {

  public final class NodeListKt {
  }

}

package de.fayard.refreshVersions.core.extensions.gradle {

  public final class AuthenticationSupportedKt {
    method public static org.gradle.api.artifacts.repositories.PasswordCredentials? getPasswordCredentials(org.gradle.api.artifacts.repositories.AuthenticationSupported);
  }

  public final class DependencyKt {
  }

  public final class ModuleIdentifierKt {
  }

  public final class ProjectKt {
  }

  public final class SettingsKt {
    method public static boolean isBuildSrc(org.gradle.api.initialization.Settings);
  }

  public final class VersionConstraintKt {
  }

}

package de.fayard.refreshVersions.core.extensions.okhttp {

  public final class CallKt {
  }

}

package de.fayard.refreshVersions.core.extensions.ranges {

  public final class IntRangeKt {
  }

}

package de.fayard.refreshVersions.core.extensions.sequences {

  public final class UniqueSequenceKt {
  }

}

package de.fayard.refreshVersions.core.extensions.text {

  public final class CharSequenceKt {
  }

  public final class StringKt {
  }

}

package de.fayard.refreshVersions.core.internal {

  @de.fayard.refreshVersions.core.internal.InternalRefreshVersionsApi public abstract class ArtifactVersionKeyReader {
    method public final operator de.fayard.refreshVersions.core.internal.ArtifactVersionKeyReader plus(de.fayard.refreshVersions.core.internal.ArtifactVersionKeyReader other);
    method public abstract String? readVersionKey(String group, String name);
    field public static final de.fayard.refreshVersions.core.internal.ArtifactVersionKeyReader.Companion Companion;
  }

  public static final class ArtifactVersionKeyReader.Companion {
    method public de.fayard.refreshVersions.core.internal.ArtifactVersionKeyReader fromRules(String fileContent);
    method public de.fayard.refreshVersions.core.internal.ArtifactVersionKeyReader fromRules(java.util.List<java.lang.String> filesContent);
  }

  @de.fayard.refreshVersions.core.internal.InternalRefreshVersionsApi public abstract class ArtifactVersionKeyRule {
    ctor protected ArtifactVersionKeyRule(String artifactPattern, String versionKeyPattern);
    method public final error.NonExistentClass! compareTo(de.fayard.refreshVersions.core.internal.ArtifactVersionKeyRule other);
    method public abstract String key(String group, String name);
    method public abstract boolean matches(String group, String name);
    method public String toString();
    field public static final de.fayard.refreshVersions.core.internal.ArtifactVersionKeyRule.Companion Companion;
  }

  public static final class ArtifactVersionKeyRule.Companion {
    method public operator de.fayard.refreshVersions.core.internal.ArtifactVersionKeyRule invoke(String artifactPattern, String versionKeyPattern);
  }

  public final class ArtifactVersionKeyRuleKt {
  }

  public final class ArtifactVersionKeyRulesChecksKt {
  }

  public final class ArtifactVersionKeysReadingKt {
  }

  @de.fayard.refreshVersions.core.internal.InternalRefreshVersionsApi public final class DependencyMapping {
    ctor public DependencyMapping(String group, String artifact, String constantName);
    method public String component1();
    method public String component2();
    method public String component3();
    method public de.fayard.refreshVersions.core.internal.DependencyMapping copy(String group, String artifact, String constantName);
    method public boolean equals(Object? other);
    method public String getArtifact();
    method public String getConstantName();
    method public String getGroup();
    method public int hashCode();
    method public String toString();
    property public final String artifact;
    property public final String constantName;
    property public final String group;
    field public static final de.fayard.refreshVersions.core.internal.DependencyMapping.Companion Companion;
  }

  public static final class DependencyMapping.Companion {
    method public de.fayard.refreshVersions.core.internal.DependencyMapping? fromLine(String line);
  }

  public final class DependencyVersionsFetcher_CompanionKt {
  }

  public final class GettingVersionCandidatesKt {
  }

  public final class InternalExtensionsKt {
    method @de.fayard.refreshVersions.core.internal.InternalRefreshVersionsApi public static boolean hasHardcodedVersion(org.gradle.api.artifacts.Dependency, java.util.Map<java.lang.String,java.lang.String> versionMap, de.fayard.refreshVersions.core.internal.ArtifactVersionKeyReader versionKeyReader);
    method @de.fayard.refreshVersions.core.internal.InternalRefreshVersionsApi public static boolean isManageableVersion(org.gradle.api.artifacts.Dependency, java.util.Map<java.lang.String,java.lang.String> versionMap, de.fayard.refreshVersions.core.internal.ArtifactVersionKeyReader versionKeyReader);
  }

  @kotlin.RequiresOptIn public @interface InternalRefreshVersionsApi {
  }

  public final class LintUpdaterKt {
  }

  public final class NewRefreshVersionsImplKt {
  }

  @de.fayard.refreshVersions.core.internal.InternalRefreshVersionsApi public enum OutputFile {
    method public final String! getAlternativePath();
    method public final boolean getExisted();
    method public final String! getPath();
    method public final void logFileWasModified(optional boolean delete);
    method public final String readText(org.gradle.api.Project project);
    method public final void setExisted(boolean existed);
    method public final void setPath(String path);
    method public final void writeText(String text, org.gradle.api.Project project, optional boolean mustExists);
    property public final String! alternativePath;
    property public final boolean existed;
    property public final String! path;
    enum_constant public static final de.fayard.refreshVersions.core.internal.OutputFile BUILD;
    enum_constant public static final de.fayard.refreshVersions.core.internal.OutputFile GIT_IGNORE;
    enum_constant public static final de.fayard.refreshVersions.core.internal.OutputFile GRADLE_VERSIONS_CATALOG;
    enum_constant public static final de.fayard.refreshVersions.core.internal.OutputFile LIBS;
    enum_constant public static final de.fayard.refreshVersions.core.internal.OutputFile OUTPUT_DIR;
    enum_constant public static final de.fayard.refreshVersions.core.internal.OutputFile SETTINGS_GRADLE;
    enum_constant public static final de.fayard.refreshVersions.core.internal.OutputFile SETTINGS_GRADLE_KTS;
    enum_constant public static final de.fayard.refreshVersions.core.internal.OutputFile VERSIONS_KT;
    enum_constant public static final de.fayard.refreshVersions.core.internal.OutputFile VERSIONS_PROPERTIES;
    field public static final de.fayard.refreshVersions.core.internal.OutputFile.Companion Companion;
  }

  public static final class OutputFile.Companion {
    method public void checkWhichFilesExist(error.NonExistentClass rootDir);
    method public void logFileWasModified(String path, boolean existed, optional boolean delete);
  }

  @de.fayard.refreshVersions.core.internal.InternalRefreshVersionsApi public final class RefreshVersionsConfigHolder {
    method public kotlin.sequences.Sequence<org.gradle.api.Project> allProjects(org.gradle.api.Project project);
    method public org.gradle.api.Project? getBuildSrc();
    method public de.fayard.refreshVersions.core.internal.ArtifactVersionKeyReader getVersionKeyReader();
    method public kotlin.jvm.functions.Function1<de.fayard.refreshVersions.core.DependencySelection,java.lang.Boolean>? getVersionRejectionFilter();
    method public error.NonExistentClass! getVersionsPropertiesFile();
    method public void markSetupViaSettingsPlugin();
    method public java.util.Map<java.lang.String,java.lang.String> readVersionsMap();
    method public void setVersionRejectionFilter(kotlin.jvm.functions.Function1<? super de.fayard.refreshVersions.core.DependencySelection,java.lang.Boolean>? versionRejectionFilter);
    property public final org.gradle.api.Project? buildSrc;
    property public final de.fayard.refreshVersions.core.internal.ArtifactVersionKeyReader versionKeyReader;
    property public final kotlin.jvm.functions.Function1<de.fayard.refreshVersions.core.DependencySelection,java.lang.Boolean>? versionRejectionFilter;
    property public final error.NonExistentClass! versionsPropertiesFile;
    field public static final de.fayard.refreshVersions.core.internal.RefreshVersionsConfigHolder INSTANCE;
  }

  public final class VersionsPlaceholdersReplacementKt {
    method @de.fayard.refreshVersions.core.internal.InternalRefreshVersionsApi public static String getVersionPropertyName(de.fayard.refreshVersions.core.ModuleId moduleId, de.fayard.refreshVersions.core.internal.ArtifactVersionKeyReader versionKeyReader);
    method @de.fayard.refreshVersions.core.internal.InternalRefreshVersionsApi public static String getVersionPropertyName(org.gradle.api.artifacts.ModuleIdentifier moduleIdentifier, de.fayard.refreshVersions.core.internal.ArtifactVersionKeyReader versionKeyReader);
    method @de.fayard.refreshVersions.core.internal.InternalRefreshVersionsApi public static void writeCurrentVersionInProperties(org.gradle.api.Project, String versionKey, String currentVersion);
  }

}

package de.fayard.refreshVersions.core.internal.cli {

  @de.fayard.refreshVersions.core.internal.InternalRefreshVersionsApi public enum AnsiColor {
    method public final String getBackground();
    method public final String getBackgroundHighIntensity();
    method public final String getBold();
    method public final String getBoldHighIntensity();
    method public final String getHighIntensity();
    method public final String getRegular();
    method public final String getUnderline();
    property public final String background;
    property public final String backgroundHighIntensity;
    property public final String bold;
    property public final String boldHighIntensity;
    property public final String highIntensity;
    property public final String regular;
    property public final String underline;
    enum_constant public static final de.fayard.refreshVersions.core.internal.cli.AnsiColor BLACK;
    enum_constant public static final de.fayard.refreshVersions.core.internal.cli.AnsiColor BLUE;
    enum_constant public static final de.fayard.refreshVersions.core.internal.cli.AnsiColor CYAN;
    enum_constant public static final de.fayard.refreshVersions.core.internal.cli.AnsiColor GREEN;
    enum_constant public static final de.fayard.refreshVersions.core.internal.cli.AnsiColor MAGENTA;
    enum_constant public static final de.fayard.refreshVersions.core.internal.cli.AnsiColor RED;
    enum_constant public static final de.fayard.refreshVersions.core.internal.cli.AnsiColor WHITE;
    enum_constant public static final de.fayard.refreshVersions.core.internal.cli.AnsiColor YELLOW;
    field public static final de.fayard.refreshVersions.core.internal.cli.AnsiColor.Companion Companion;
    field public static final String RESET = "\u001b[0m";
  }

  public static final class AnsiColor.Companion {
  }

  @de.fayard.refreshVersions.core.internal.InternalRefreshVersionsApi public interface CliGenericUi {
    method public boolean askBinaryQuestion(String question, String trueChoice, String falseChoice);
    method public int showMenuAndGetIndexOfChoice(String header, String footer, java.util.List<java.lang.String> numberedEntries);
    field public static final de.fayard.refreshVersions.core.internal.cli.CliGenericUi.Companion Companion;
  }

  public static final class CliGenericUi.Companion {
    method public operator de.fayard.refreshVersions.core.internal.cli.CliGenericUi invoke();
  }

  @de.fayard.refreshVersions.core.internal.InternalRefreshVersionsApi public final inline class MenuEntryIndex {
    ctor public MenuEntryIndex();
    method public int getValue();
    property public final int value;
  }

}

package de.fayard.refreshVersions.core.internal.codeparsing {

  public final class ArgumentsExtractingKt {
  }

  public final class SourceCodeRangesFindingKt {
  }

  public final class StringBuilderKt {
  }

  public final class SymbolLocationFindingKt {
  }

}

package de.fayard.refreshVersions.core.internal.codeparsing.gradle {

  public final class GradleScriptParsingKt {
  }

  public final class PluginBlocksLocatingKt {
  }

}

package de.fayard.refreshVersions.core.internal.legacy {

  @de.fayard.refreshVersions.core.internal.InternalRefreshVersionsApi public final class LegacyBootstrapMigrator {
    ctor public LegacyBootstrapMigrator(boolean isBuildSrc, boolean isKotlinDsl);
    field public static final de.fayard.refreshVersions.core.internal.legacy.LegacyBootstrapMigrator.Companion Companion;
  }

  public static final class LegacyBootstrapMigrator.Companion {
    method public void replaceBootstrapWithPluginsDslSetup(org.gradle.api.initialization.Settings);
  }

  public final class LegacyBootstrapUpdaterKt {
  }

}

package de.fayard.refreshVersions.core.internal.problems {

  public final class ProblemLoggingKt {
  }

}

package de.fayard.refreshVersions.core.internal.versions {

  public final class VersionsPropertiesReadingKt {
  }

  public final class VersionsPropertiesTransformKt {
  }

  public final class VersionsPropertiesWritingKt {
  }

}

package de.fayard.refreshVersions.internal {

  public final class ConfigurationDependenciesMigrationKt {
  }

  public final class MappingKt {
  }

  public final class MigrationToDependenciesConstantsKt {
  }

}

package org.gradle.kotlin.dsl {

  public final class RefreshVersionsKt {
    method public static inline void refreshVersions(org.gradle.api.initialization.Settings, kotlin.jvm.functions.Function1<? super de.fayard.refreshVersions.RefreshVersionsExtension,kotlin.Unit> configure);
  }

}

