// Signature format: 4.0
package  {

  public final class DependencyMappersKt {
    method public static void dependencyMapper(org.gradle.api.initialization.Settings, optional kotlin.jvm.functions.Function1<? super com.meowool.gradle.toolkit.DependencyMapperExtension,kotlin.Unit> configuration);
    method public static void dependencyMapper(error.NonExistentClass, optional kotlin.jvm.functions.Function1<? super com.meowool.gradle.toolkit.DependencyMapperExtension,kotlin.Unit> configuration);
    method public static com.meowool.gradle.toolkit.DependencyMapperExtension getDependencyMapper(error.NonExistentClass);
  }

}

package com.meowool.gradle.toolkit {

  public abstract class DependencyMapperExtension {
    ctor public DependencyMapperExtension(org.gradle.api.Project project);
    method public final void alwaysUpdate();
    method public final void capitalizeFirstLetter(optional kotlin.jvm.functions.Function1<? super java.lang.String,java.lang.Boolean> predicate);
    method public final String getRootClassName();
    method public final void mapDependencies(java.lang.String... dependencies);
    method public final void mapDependencies(kotlin.Pair<java.lang.String,java.lang.String>... mappingDependencies);
    method public final void remoteDependencies(kotlin.jvm.functions.Function1<? super com.meowool.gradle.toolkit.internal.RemoteDependencies,kotlin.Unit> configuration);
    method public final void setRootClassName(String rootClassName);
    method public final void transformName(kotlin.jvm.functions.Function1<? super java.lang.String,java.lang.String> transformation);
    method public final void transformNotation(kotlin.jvm.functions.Function1<? super java.lang.String,java.lang.String> transformation);
    method public final void updateWhen(kotlin.jvm.functions.Function1<? super org.gradle.api.Project,java.lang.Boolean> predicate);
    property public final String rootClassName;
  }

  public final class DependencyMapperExtensionKt {
  }

  public final class DependencyMapperPlugin implements org.gradle.api.Plugin<java.lang.Object> {
    ctor public DependencyMapperPlugin();
    method public void apply(Object target);
  }

}

package com.meowool.gradle.toolkit.internal {

  public final class Dependency {
    method public boolean equals(Object? other);
    method public String getArtifact();
    method public String getGroup();
    method public int hashCode();
    method public String toString();
    property public final String artifact;
    property public final String group;
  }

  public final class RemoteDependencies {
    method public void filter(kotlin.jvm.functions.Function1<? super com.meowool.gradle.toolkit.internal.Dependency,java.lang.Boolean> predicate);
    method public boolean groups(String![] dependencyGroupIds, optional kotlin.jvm.functions.Function1<? super com.meowool.gradle.toolkit.internal.RemoteRepositories,kotlin.Unit>? repositories, optional kotlin.jvm.functions.Function1<? super com.meowool.gradle.toolkit.internal.Dependency,java.lang.Boolean>? filter);
    method public boolean keywords(String![] dependencyKeywords, optional kotlin.jvm.functions.Function1<? super com.meowool.gradle.toolkit.internal.RemoteRepositories,kotlin.Unit>? repositories, optional kotlin.jvm.functions.Function1<? super com.meowool.gradle.toolkit.internal.Dependency,java.lang.Boolean>? filter);
    method public void repositories(kotlin.jvm.functions.Function1<? super com.meowool.gradle.toolkit.internal.RemoteRepositories,kotlin.Unit> configuration);
    method public boolean startsWith(String![] beginningKeywords, optional kotlin.jvm.functions.Function1<? super com.meowool.gradle.toolkit.internal.RemoteRepositories,kotlin.Unit>? repositories, optional kotlin.jvm.functions.Function1<? super com.meowool.gradle.toolkit.internal.Dependency,java.lang.Boolean>? filter);
  }

  public final class RemoteRepositories {
    method public void google();
    method public void mavenCentral();
    method public void mvnrepository(optional boolean fetchExactly);
    field public static final com.meowool.gradle.toolkit.internal.RemoteRepositories.Companion Companion;
  }

  public static final class RemoteRepositories.Companion {
  }

  public final class UtilsKt {
    method public static suspend <T> Object? contains(kotlinx.coroutines.flow.Flow<? extends T>, T? element, kotlin.coroutines.Continuation<? super java.lang.Boolean> p);
  }

}

