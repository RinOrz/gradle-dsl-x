/*
 * Copyright (c) 2021. The Meowool Organization Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * In addition, if you modified the project, you must include the Meowool
 * organization URL in your code file: https://github.com/meowool
 */
@file:Suppress("NOTHING_TO_INLINE")

import com.android.build.gradle.AppExtension
import com.android.build.gradle.BaseExtension
import com.android.build.gradle.LibraryExtension
import com.android.build.gradle.TestedExtension
import com.android.build.gradle.api.BaseVariant
import kotlinx.coroutines.MainScope
import kotlinx.coroutines.cancel
import kotlinx.coroutines.launch
import net.mbonnin.vespene.lib.NexusStagingClient
import org.gradle.api.Project
import org.gradle.api.artifacts.repositories.MavenArtifactRepository
import org.gradle.api.artifacts.repositories.PasswordCredentials
import org.gradle.api.plugins.JavaPluginConvention
import org.gradle.api.publish.maven.MavenPublication
import org.gradle.api.publish.maven.plugins.MavenPublishPlugin
import org.gradle.jvm.tasks.Jar
import org.gradle.kotlin.dsl.apply
import org.gradle.kotlin.dsl.configure
import org.gradle.kotlin.dsl.create
import org.gradle.kotlin.dsl.findByType
import org.gradle.kotlin.dsl.getCredentials
import org.gradle.kotlin.dsl.getValue
import org.gradle.kotlin.dsl.hasPlugin
import org.gradle.kotlin.dsl.maven
import org.gradle.kotlin.dsl.publishing
import org.gradle.kotlin.dsl.register
import org.gradle.kotlin.dsl.withType
import org.gradle.plugins.signing.SigningExtension
import org.gradle.plugins.signing.SigningPlugin
import org.jetbrains.dokka.gradle.DokkaPlugin
import org.jetbrains.dokka.gradle.DokkaTask
import org.jetbrains.kotlin.gradle.dsl.KotlinMultiplatformExtension

/**
 * Configure the maven publishing.
 *
 * @param repo The urls of the target repository to publish to.
 * @param pom The maven pom data of artifact to published.
 * @param releaseSigning Whether to signing the artifact of release version.
 * @param snapshotSigning Whether to signing the artifact of snapshot version.
 * @param dokkaFormat The output format of documents generated by dokka.
 *
 * @author å‡› (https://github.com/RinOrz)
 */
fun Project.mavenPublish(
  repo: Array<RepoUrl> = arrayOf(SonatypeRepo()),
  pom: PublishPom = publishPom(),
  releaseSigning: Boolean = true,
  snapshotSigning: Boolean = false,
  dokkaFormat: DokkaFormat = DokkaFormat.Html
) {
  group = pom.group
  version = pom.version
  description = pom.description

  afterEvaluate {
    if (!plugins.hasPlugin(MavenPublishPlugin::class)) apply<MavenPublishPlugin>()
    if (!plugins.hasPlugin(DokkaPlugin::class)) apply<DokkaPlugin>()
    if (!plugins.hasPlugin(SigningPlugin::class) && (releaseSigning || snapshotSigning)) apply<SigningPlugin>()

    val javaConvention = convention.getPlugin(JavaPluginConvention::class.java)
    val isKotlinMultiplatform = extensions.findByType<KotlinMultiplatformExtension>() != null
    val androidExtension = extensions.findByName("android") as? BaseExtension
    val isAndroid = androidExtension != null

    publishing {
      // Configure is not kotlin-multiplatform publications.
      if (isKotlinMultiplatform.not()) {
        val sourcesJar by tasks.register<Jar>(if (isAndroid) "androidSourcesJar" else "jvmSourcesJar") {
          archiveClassifier.set("sources")
          val kotlinSourcesJar = tasks.findByName("kotlinSourcesJar")
          when {
            isAndroid -> from(androidExtension!!.sourceSets.getByName("main").java.srcDirs)
            // Hand it over to kotlin
            kotlinSourcesJar != null -> dependsOn(kotlinSourcesJar)
            else -> from(javaConvention.sourceSets.getByName("main").allSource)
          }
        }

        // Configure the artifact of sources jar.
        when {
          isAndroid -> androidExtension?.variants {
            publications.create<MavenPublication>(this.name) {
              from(components.getByName(this.name))
              artifact(sourcesJar)
            }
          }
          else -> publications.create<MavenPublication>("maven") {
            components.findByName("java")?.let(::from)
              ?: components.findByName("kotlin")?.let(::from)
            artifact(sourcesJar)
          }
        }
      }

      val dokkaJar by tasks.register<Jar>("dokkaJar") {
        archiveClassifier.set("javadoc")

        val dokkaTask = tasks.findByName(dokkaFormat.taskName) as? DokkaTask
          ?: tasks.withType<DokkaTask>().first()
        dependsOn(dokkaTask)
        from(dokkaTask.outputDirectory)
      }

      // Configure all maven publications.
      publications.withType<MavenPublication> {
        artifact(dokkaJar)
        pom { pom.configuration(this) }
        afterEvaluate {
          version = pom.version
          groupId = pom.group
          // There will be a suffix when a multi-platform project, so use the way of prefix replacing.
          artifactId = pom.artifact + artifactId.removePrefix(project.name)
        }
      }

      // Target repository to publish to.
      repositories {
        repo.forEach {
          val url = if (pom.isSnapshot) it.snapshots else it.releases
          val maven = if (url == LocalRepo::class) mavenLocal() else maven(url)
          if (it.requiredCertificate) maven.credentials(PasswordCredentials::class.java)
        }
      }
    }

    // Publish a release version with the snapshot suffix removed and close the nexus repository.
    publishReleaseVersion()

    // Signing the artifact.
    extensions.configure<SigningExtension> {
      val isSigning = when {
        releaseSigning && !snapshotSigning -> pom.isSnapshot.not()
        !releaseSigning && snapshotSigning -> pom.isSnapshot
        releaseSigning && snapshotSigning -> true
        else -> false
      }
      setRequired { isSigning && gradle.taskGraph.hasTask("uploadArchives") }
      if (isSigning) sign(publishing.publications)
    }
  }
}

/**
 * Configure the maven publishing.
 *
 * @param repo The url of the target repository to publish to.
 * @param pom The maven pom data of artifact to published.
 * @param releaseSigning Whether to signing the artifact of release version.
 * @param snapshotSigning Whether to signing the artifact of snapshot version.
 */
inline fun Project.mavenPublish(
  repo: RepoUrl,
  pom: PublishPom = publishPom(),
  releaseSigning: Boolean = true,
  snapshotSigning: Boolean = false,
) = mavenPublish(arrayOf(repo), pom, releaseSigning, snapshotSigning)


private fun Project.publishReleaseVersion() {
  tasks.register("publishReleaseVersion") {
    var bakVersion: Any? = null
    group = "publishing"
    description = "Publishes all release version publications with the snapshot suffix removed and close the nexus repository."
    dependsOn(tasks.getByName("publish"))
    doFirst {
      bakVersion = this.project.version
      this.project.version = bakVersion.toString().removeSuffix("-SNAPSHOT")
    }
    doLast {
      val credential = repositories.filterIsInstance<MavenArtifactRepository>()
        .map { it.getCredentials(PasswordCredentials::class) }
        .firstOrNull()

      val client = NexusStagingClient(
        username = findPropertyOrEnv("sonatypeUsername")?.toString()
          ?: credential?.username
          ?: error("To close the nexus repository you must define `sonatypeUsername` in gradle.properties (Gradle Home) to verify your identity."),
        password = findPropertyOrEnv("sonatypePassword")?.toString() ?: credential?.password
          ?: error("To close the nexus repository you must define `sonatypePassword` in gradle.properties (Gradle Home) to verify your identity."),
      )

      val scope = MainScope()
      scope.launch {
        val repositoryIds = client.getRepositories().map { it.repositoryId }
        client.closeRepositories(repositoryIds)
        client.releaseRepositories(repositoryIds, dropAfterRelease = true)
        scope.cancel()
      }

      // Revert the version (snapshot).
      this.project.version = bakVersion!!
    }
  }
}

private fun BaseExtension.variants(configuration: BaseVariant.() -> Unit) {
  (this as? AppExtension)?.applicationVariants?.configureEach(configuration)
    ?: (this as? LibraryExtension)?.libraryVariants?.configureEach(configuration)
    ?: (this as? TestedExtension)?.testVariants?.configureEach(configuration)
}