/*
 * Copyright (c) 2021. The Meowool Organization Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * In addition, if you modified the project, you must include the Meowool
 * organization URL in your code file: https://github.com/meowool
 */
@file:Suppress("NOTHING_TO_INLINE")

import com.android.build.gradle.AppExtension
import com.android.build.gradle.BaseExtension
import com.android.build.gradle.LibraryExtension
import com.android.build.gradle.TestedExtension
import com.android.build.gradle.api.BaseVariant
import com.github.michaelbull.retry.policy.constantDelay
import com.github.michaelbull.retry.policy.limitAttempts
import com.github.michaelbull.retry.policy.plus
import com.github.michaelbull.retry.retry
import groovy.util.Node
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.asFlow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.retry
import kotlinx.coroutines.runBlocking
import net.mbonnin.vespene.lib.NexusStagingClient
import org.gradle.BuildAdapter
import org.gradle.BuildResult
import org.gradle.api.Project
import org.gradle.api.artifacts.repositories.AuthenticationSupported
import org.gradle.api.artifacts.repositories.MavenArtifactRepository
import org.gradle.api.artifacts.repositories.PasswordCredentials
import org.gradle.api.plugins.JavaPluginConvention
import org.gradle.api.plugins.JavaPluginExtension
import org.gradle.api.publish.PublishingExtension
import org.gradle.api.publish.maven.MavenPublication
import org.gradle.api.publish.maven.plugins.MavenPublishPlugin
import org.gradle.api.publish.maven.tasks.PublishToMavenRepository
import org.gradle.api.publish.plugins.PublishingPlugin
import org.gradle.jvm.tasks.Jar
import org.gradle.kotlin.dsl.apply
import org.gradle.kotlin.dsl.create
import org.gradle.kotlin.dsl.extra
import org.gradle.kotlin.dsl.findByType
import org.gradle.kotlin.dsl.getByType
import org.gradle.kotlin.dsl.getCredentials
import org.gradle.kotlin.dsl.getValue
import org.gradle.kotlin.dsl.hasPlugin
import org.gradle.kotlin.dsl.maven
import org.gradle.kotlin.dsl.publishing
import org.gradle.kotlin.dsl.register
import org.gradle.kotlin.dsl.withType
import org.gradle.plugins.signing.SigningExtension
import org.gradle.plugins.signing.SigningPlugin
import org.jetbrains.dokka.gradle.DokkaPlugin
import org.jetbrains.dokka.gradle.DokkaTask
import org.jetbrains.kotlin.gradle.dsl.KotlinMultiplatformExtension


/**
 * Configure the maven publishing.
 *
 * @param repo The url of the target repository to publish to.
 * @param pom The maven pom data of artifact to published.
 * @param releaseSigning Whether to signing the artifact of release version.
 * @param snapshotSigning Whether to signing the artifact of snapshot version.
 *
 * @author å‡› (https://github.com/RinOrz)
 */
inline fun Project.mavenPublish(
  repo: RepoUrl,
  pom: PublishPom = PublishPom(),
  releaseSigning: Boolean = true,
  snapshotSigning: Boolean = false,
) = mavenPublish(arrayOf(repo), pom, releaseSigning, snapshotSigning)

/**
 * Configure the maven publishing.
 *
 * @param repo The urls of the target repository to publish to.
 * @param pom The maven pom data of artifact to published.
 * @param releaseSigning Whether to signing the artifact of release version.
 * @param snapshotSigning Whether to signing the artifact of snapshot version.
 * @param dokkaFormat The output format of documents generated by dokka.
 */
fun Project.mavenPublish(
  repo: Array<RepoUrl> = arrayOf(SonatypeRepo()),
  pom: PublishPom = PublishPom(),
  releaseSigning: Boolean = true,
  snapshotSigning: Boolean = false,
  dokkaFormat: DokkaFormat = DokkaFormat.Html,
) {
  if (buildFile.exists().not()) return
  repo.forEach { it.isSnapshot = pom.isSnapshot }
  configurePom(pom)
  publishComponentsAndSourcesJar()
  publishDokkaJar(dokkaFormat)
  configureRepositories(repo)
  configureSignings(pom, releaseSigning, snapshotSigning)

  // Sonatype
  initSonatypeBuild()
  repo.filterIsInstance<SonatypeRepo>().firstOrNull()?.let {
    initializeSonatypeStaging(pom, it)
    closeAndReleaseSonatypeRepository(it)
  }
}


//////////////////////////////////////////////////
//               Internal logics                //
//////////////////////////////////////////////////

/**
 * Configures the pom to publish.
 */
internal fun Project.configurePom(pom: PublishPom) {
  group = pom.group
  version = pom.version
  description = pom.description

  afterEvaluate {
    if (!plugins.hasPlugin(MavenPublishPlugin::class)) apply<MavenPublishPlugin>()

    publishing.publications.withType<MavenPublication> {
      pom {
        pom.configuration(this)
        // Collect all the repositories used in the project to add to the POM
        // See https://maven.apache.org/pom.html#Repositories)
        withXml {
          project.repositories
            .filterIsInstance<MavenArtifactRepository>()
            .filterNot { it.url.host.contains("repo.maven.apache.org") }
            .takeIf { it.isNotEmpty() }
            ?.also { repositories ->
              val xml = this.asNode()
              // Find or create `repositories` node
              val repositoriesNode = xml.children()
                .filterIsInstance<Node>()
                .firstOrNull { it.name() == "repositories" }
                ?: xml.appendNode("repositories")

              repositories.forEach { repo ->
                repositoriesNode?.appendNode("repository")?.apply {
                  appendNode("id", repo.name)
                  appendNode("url", repo.url.toString())
                }
              }
            }
        }
      }

      version = pom.version
      groupId = pom.group
      // Ref: https://github.com/vanniktech/gradle-maven-publish-plugin/blob/a824079592fd0e1895aa0b293b798f593949fadb/plugin/src/main/kotlin/com/vanniktech/maven/publish/legacy/Coordinates.kt#L25
      if (this@withType.name.endsWith("PluginMarkerMaven").not()) {
        // There will be a suffix when a multi-platform project, so use the way of prefix replacing.
        artifactId = pom.artifact + artifactId.removePrefix(project.name)
      }
    }
  }
}

/**
 * Configures the project components and sources jar to publish.
 */
internal fun Project.publishComponentsAndSourcesJar() = afterEvaluate {
  publishing {
    val androidExtension = extensions.findByName("android") as? BaseExtension
    val isAndroid = androidExtension != null

    // The kotlin multiplatform plugin publishes its own components
    if (extensions.findByType<KotlinMultiplatformExtension>() != null) return@publishing

    val sourcesJar by tasks.register<Jar>(if (isAndroid) "androidSourcesJar" else "jvmSourcesJar") {
      archiveClassifier.set("sources")
      val kotlinSourcesJar = tasks.findByName("kotlinSourcesJar")
      when {
        isAndroid -> from(androidExtension!!.sourceSets.getByName("main").java.srcDirs)
        // Hand it over to kotlin
        kotlinSourcesJar != null -> dependsOn(kotlinSourcesJar)
        else -> from(project.extensions.getByType<JavaPluginExtension>().sourceSets.getByName("main").allSource)
      }
    }

    // Configure artifacts with sources jar.
    when {
      isAndroid -> androidExtension!!.configureAllVariants {
        publications.create<MavenPublication>(this.name) {
          from(components.getByName(this.name))
          artifact(sourcesJar)
        }
      }
      else -> publications.create<MavenPublication>("maven") {
        components.findByName("java")?.let(::from) ?: components.findByName("kotlin")?.let(::from)
        artifact(sourcesJar)
      }
    }
  }
}

/**
 * Configures the dokka jar to publish.
 */
internal fun Project.publishDokkaJar(format: DokkaFormat) = afterEvaluate {
  if (!plugins.hasPlugin(DokkaPlugin::class)) apply<DokkaPlugin>()

  val dokkaJar by tasks.register<Jar>("dokkaJar") {
    archiveClassifier.set("javadoc")

    val dokkaTask = tasks.findByName(format.taskName) as? DokkaTask ?: tasks.withType<DokkaTask>().first()
    dependsOn(dokkaTask)
    from(dokkaTask.outputDirectory)
  }
  // Configures dokka jar to all publications
  publishing.publications.withType<MavenPublication> { artifact(dokkaJar) }
}

/**
 * Configures target repositories to publish artifacts.
 */
internal fun Project.configureRepositories(repo: Array<RepoUrl>) = afterEvaluate {
  publishing.repositories {
    repo.forEach {
      it.project = project
      val url = it.url
      val maven = if (url == LocalRepo::class) mavenLocal() else maven(it.url)
      if (it.requiredCertificate) maven.credentials(PasswordCredentials::class.java)
    }
  }
}

/**
 * Configures the signings to sign artifacts to publish.
 */
internal fun Project.configureSignings(
  pom: PublishPom,
  releaseSigning: Boolean,
  snapshotSigning: Boolean,
) = afterEvaluate {
  if (!plugins.hasPlugin(SigningPlugin::class) && (releaseSigning || snapshotSigning)) apply<SigningPlugin>()

  // Signing the artifacts
  extensions.findByType<SigningExtension>()?.apply {
    isRequired = when {
      releaseSigning && snapshotSigning.not() -> pom.isSnapshot.not()
      snapshotSigning && releaseSigning.not() -> pom.isSnapshot
      releaseSigning && snapshotSigning -> true
      else -> false
    }
    if (isRequired) sign(publishing.publications)
  }
}

private fun BaseExtension.configureAllVariants(configuration: BaseVariant.() -> Unit) {
  (this as? AppExtension)?.applicationVariants?.configureEach(configuration)
    ?: (this as? LibraryExtension)?.libraryVariants?.configureEach(configuration)
    ?: (this as? TestedExtension)?.testVariants?.configureEach(configuration)
}

/**
 * Creates a new nexus staging client.
 */
private fun Project.createNexusStagingClient(baseUrl: String): NexusStagingClient {
  val credential = extensions.findByType<PublishingExtension>()?.repositories
    ?.filterIsInstance<AuthenticationSupported>()
    ?.map { it.getCredentials(PasswordCredentials::class) }
    ?.firstOrNull()

  return NexusStagingClient(
    baseUrl = "$baseUrl/service/local/",
    username = findPropertyOrEnv("sonatypeUsername")?.toString()
      ?: findPropertyOrEnv("mavenUsername")?.toString()
      ?: credential?.username
      ?: error("To close the nexus repository you must define `sonatypeUsername` in gradle.properties (Gradle Home) to verify your identity."),
    password = findPropertyOrEnv("sonatypePassword")?.toString()
      ?: findPropertyOrEnv("mavenPassword")?.toString()
      ?: credential?.password
      ?: error("To close the nexus repository you must define `sonatypePassword` in gradle.properties (Gradle Home) to verify your identity."),
  )
}

private fun Project.initSonatypeBuild() {
  // Listening to build finished and to close repositories, only need to add to root project once
  if (buildListener.not()) {
    buildListener = true
    rootProject.gradle.addBuildListener(object : BuildAdapter() {
      override fun buildFinished(result: BuildResult) {
        super.buildFinished(result)
        runBlocking {
          @Suppress("UNCHECKED_CAST")
          repositoriesToClose.forEach { (baseUrl, repositoryIds) ->
            val client = rootProject.createNexusStagingClient(baseUrl)
            repositoryIds.asFlow().map {
              val id = listOf(it)
              println("Closing $it")
              client.closeRepositories(id)
              println("Releasing $it")
              client.releaseRepositories(id, dropAfterRelease = true)
            }.retry(retries = 5) {
              // Retry after 1000 ms
              delay(1000)
              true
            }
          }
          repositoriesToClose.clear()
        }
      }
    })
  }
}

/**
 * The task used to initialize the sonatype staging repository.
 */
private fun Project.initializeSonatypeStaging(pom: PublishPom, repo: SonatypeRepo) = afterEvaluate {
  tasks.withType<PublishToMavenRepository>().all {
    doFirst {
      // Don't redirect the publish of snapshot artifacts
      if (repo.isSnapshot.not()) runBlocking {
        retry(limitAttempts(5) + constantDelay(1000L)) {
          val client = project.createNexusStagingClient(repo.baseUrl)
          val description = publication.stagingDescription
          val profiles = client.getProfiles()
          val profile = profiles.firstOrNull { group == it.name || pom.group == it.name }
            ?: profiles.firstOrNull { group?.startsWith(it.name) == true || pom.group.startsWith(it.name) }
            ?: profiles.firstOrNull()
            ?: return@retry

          // Check staging repository if exists in nexus
          val existing = client.getRepositories().firstOrNull {
            it.description == description && it.transitioning.not() && it.type == "open"
          }

          repo.stagingId = when {
            existing != null -> existing.repositoryId
            else -> client.createRepository(profile.id, description)
          }

          // Redirects the repository url to specific staging repository
          repository.setUrl(repo.url)
        }
      }

      println("Publishing to ${repository.url}")
    }
  }
}

/**
 * The task used to close and release sonatype staging repository.
 */
private fun Project.closeAndReleaseSonatypeRepository(repo: SonatypeRepo) = afterEvaluate {
  tasks.create("closeAndReleaseSonatypeRepository") {
    group = PublishingPlugin.PUBLISH_TASK_GROUP
    description = "Closes release version in the nexus repository."
    doLast {
      runBlocking {
        val client = project.createNexusStagingClient(repo.baseUrl)
        val repositoryIds = tasks.withType<PublishToMavenRepository>().mapNotNull {
          retry(limitAttempts(5) + constantDelay(1000L)) {
            val description = it.publication.stagingDescription
            client.getRepositories()
              .firstOrNull { it.description == description }
              ?.repositoryId
          }
        }
        // Collect the repository ids to close
        repositoriesToClose
          .getOrPut(repo.baseUrl) { mutableSetOf() }
          .addAll(repositoryIds)
      }
    }
  }
}

private const val BUILD_LISTENER = "mavenPublish-buildListener"
private const val REPOSITORIES_TO_CLOSE = "mavenPublish-waitForCloseRepositories"

/**
 * Represents the build listener for the root project.
 */
private var Project.buildListener: Boolean
  set(value) = rootProject.extra.set(BUILD_LISTENER, value)
  get() = rootProject.extra.properties[BUILD_LISTENER] == true


/**
 * The map to represents the repositories to be closed and its url.
 */
private val Project.repositoriesToClose: MutableMap<String, MutableSet<String>>
  get() {
    if (rootProject.extra.has(REPOSITORIES_TO_CLOSE).not()) {
      rootProject.extra[REPOSITORIES_TO_CLOSE] = mutableMapOf<String, MutableSet<String>>()
    }
    @Suppress("UNCHECKED_CAST")
    return rootProject.extra[REPOSITORIES_TO_CLOSE] as MutableMap<String, MutableSet<String>>
  }

/**
 * Returns the description of staging repository.
 */
private val MavenPublication.stagingDescription: String get() = "Staging $groupId:$artifactId:$version"