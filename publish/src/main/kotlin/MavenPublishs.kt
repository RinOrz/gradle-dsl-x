/*
 * Copyright (c) 2021. The Meowool Organization Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * In addition, if you modified the project, you must include the Meowool
 * organization URL in your code file: https://github.com/meowool
 */
@file:Suppress("NOTHING_TO_INLINE")

import PublishingData.Companion.publishingDataExtensions
import com.android.build.gradle.AppExtension
import com.android.build.gradle.BaseExtension
import com.android.build.gradle.LibraryExtension
import com.android.build.gradle.TestedExtension
import com.android.build.gradle.api.BaseVariant
import groovy.util.Node
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.asFlow
import kotlinx.coroutines.flow.collect
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.retry
import kotlinx.coroutines.runBlocking
import net.mbonnin.vespene.lib.NexusStagingClient
import org.gradle.BuildAdapter
import org.gradle.BuildResult
import org.gradle.api.Project
import org.gradle.api.artifacts.repositories.AuthenticationSupported
import org.gradle.api.artifacts.repositories.MavenArtifactRepository
import org.gradle.api.artifacts.repositories.PasswordCredentials
import org.gradle.api.plugins.JavaPluginExtension
import org.gradle.api.publish.PublishingExtension
import org.gradle.api.publish.maven.MavenPublication
import org.gradle.api.publish.maven.plugins.MavenPublishPlugin
import org.gradle.api.publish.maven.tasks.PublishToMavenRepository
import org.gradle.api.publish.plugins.PublishingPlugin
import org.gradle.jvm.tasks.Jar
import org.gradle.kotlin.dsl.apply
import org.gradle.kotlin.dsl.configure
import org.gradle.kotlin.dsl.create
import org.gradle.kotlin.dsl.extra
import org.gradle.kotlin.dsl.findByType
import org.gradle.kotlin.dsl.get
import org.gradle.kotlin.dsl.getByType
import org.gradle.kotlin.dsl.getCredentials
import org.gradle.kotlin.dsl.getValue
import org.gradle.kotlin.dsl.maven
import org.gradle.kotlin.dsl.provideDelegate
import org.gradle.kotlin.dsl.publishing
import org.gradle.kotlin.dsl.register
import org.gradle.kotlin.dsl.withType
import org.gradle.plugins.signing.SigningExtension
import org.gradle.plugins.signing.SigningPlugin
import org.jetbrains.dokka.gradle.DokkaPlugin
import org.jetbrains.dokka.gradle.DokkaTask
import org.jetbrains.kotlin.gradle.dsl.KotlinMultiplatformExtension


/**
 * Configure the maven publishing.
 *
 * @param repo The url of the target repository to publish to.
 * @param releaseSigning Whether to signing the artifact of release version.
 * @param snapshotSigning Whether to signing the artifact of snapshot version.
 *
 * @author å‡› (https://github.com/RinOrz)
 */
inline fun Project.mavenPublish(
  repo: RepoUrl,
  releaseSigning: Boolean = true,
  snapshotSigning: Boolean = false,
) = mavenPublish(arrayOf(repo), releaseSigning, snapshotSigning)

/**
 * Configure the maven publishing.
 *
 * @param repo The urls of the target repository to publish to.
 * @param releaseSigning Whether to signing the artifact of release version. For more details, see
 *   [Gradle documentation](https://docs.gradle.org/current/userguide/signing_plugin.html).
 * @param snapshotSigning Whether to signing the artifact of snapshot version. For more details, see
 *   [Gradle documentation](https://docs.gradle.org/current/userguide/signing_plugin.html).
 * @param dokkaFormat The output format of documents generated by dokka.
 */
fun Project.mavenPublish(
  repo: Array<RepoUrl> = arrayOf(SonatypeRepo()),
  releaseSigning: Boolean = true,
  snapshotSigning: Boolean = false,
  dokkaFormat: DokkaFormat = DokkaFormat.Html,
) {
  if (buildFile.exists().not()) return
  val publishingData = publishingDataExtensions
  repo.forEach { it.isSnapshot = publishingData.isSnapshot }
  configurePom(publishingData)
  publishComponentsAndSourcesJar()
  publishDokkaJar(dokkaFormat)
  configureRepositories(repo)
  configureSignings(publishingData, releaseSigning, snapshotSigning)

  // Sonatype
  initSonatypeBuild()
  repo.filterIsInstance<SonatypeRepo>().firstOrNull()?.let {
    initializeSonatypeStaging(publishingData, it)
    closeAndReleaseSonatypeRepository(it)
  }
}


///////////////////////////////////////////////////////
////                 Internal APIs                 ////
///////////////////////////////////////////////////////

/**
 * Configures the pom to publish.
 */
private fun Project.configurePom(data: PublishingData) {
  group = data.group
  version = data.version
  description = data.description

  afterEvaluate {
    apply<MavenPublishPlugin>()
    publishing.publications.withType<MavenPublication> {
      pom {
        name.set(data.name)
        url.set(data.url)
        data.description?.let(description::set)
        licenses {
          data.licenses.forEach {
            license {
              it.name?.let(name::set)
              it.url?.let(url::set)
              it.distribution?.let(distribution::set)
              it.comments?.let(comments::set)
            }
          }
        }
        developers {
          data.developers.forEach {
            developer {
              it.id?.let(id::set)
              it.name?.let(name::set)
              it.url?.let(url::set)
            }
          }
        }
        organization {
          data.organizationName?.let(name::set)
          data.organizationUrl?.let(url::set)
        }
        scm {
          data.scmConnection?.let(connection::set)
          data.scmUrl?.let(url::set)
        }

        // Collect all the repositories used in the project to add to the POM
        // See https://maven.apache.org/pom.html#Repositories
        withXml {
          project.repositories
            .filterIsInstance<MavenArtifactRepository>()
            .filterNot { it.url.host.contains("repo.maven.apache.org") }
            .takeIf { it.isNotEmpty() }
            ?.also { repositories ->
              val xml = this.asNode()
              // Find or create `repositories` node
              val repositoriesNode = xml.children().firstOrNull { it is Node && it.name() == "repositories" } as? Node
                ?: xml.appendNode("repositories")

              repositories.forEach { repo ->
                repositoriesNode?.appendNode("repository")?.apply {
                  appendNode("id", repo.name)
                  appendNode("url", repo.url.toString())
                }
              }
            }
        }

        data.pomConfigurations.forEach { it() }
      }

      version = data.version
      groupId = data.group
      // Ref: https://github.com/vanniktech/gradle-maven-publish-plugin/blob/a824079592fd0e1895aa0b293b798f593949fadb/plugin/src/main/kotlin/com/vanniktech/maven/publish/legacy/Coordinates.kt#L25
      if (this@withType.name.endsWith("PluginMarkerMaven").not()) {
        // There will be a suffix when a multi-platform project, so use the way of prefix replacing.
        artifactId = data.artifact + artifactId.removePrefix(project.name)
      }
    }
  }
}

/**
 * Configures the project components and sources jar to publish.
 */
private fun Project.publishComponentsAndSourcesJar() = afterEvaluate {
  publishing {
    // The kotlin multiplatform plugin publishes its own components
    if (extensions.findByType<KotlinMultiplatformExtension>() != null) return@publishing

    val androidExtension = extensions.findByName("android") as? BaseExtension
    val isAndroid = androidExtension != null
    val kotlinSourcesJar = tasks.findByName("kotlinSourcesJar")
    val sourcesJar = when {
      isAndroid -> sourcesJar("androidSourcesJar") { from(androidExtension!!.sourceSets.getByName("main").java.srcDirs) }
      // Hand it over to kotlin
      kotlinSourcesJar != null -> kotlinSourcesJar
      else -> sourcesJar("javaSourcesJar") { from(extensions.getByType<JavaPluginExtension>().sourceSets.getByName("main").allSource) }
    }

    // Configure artifacts with sources jar
    when {
      isAndroid -> androidExtension!!.configureAllVariants { variant ->
        publications.create<MavenPublication>(variant.name) {
          from(components[variant.name])
          artifact(sourcesJar)
        }
      }
      else -> publications.create<MavenPublication>("maven") {
        components.findByName("kotlin")?.let(::from) ?: components.findByName("java")?.let(::from)
        artifact(sourcesJar)
      }
    }
  }
}

private fun Project.sourcesJar(name: String, block: Jar.() -> Unit) = tasks.register<Jar>(name) {
  archiveClassifier.set("sources")
  block()
}.get()

/**
 * Configures the dokka jar to publish.
 */
private fun Project.publishDokkaJar(format: DokkaFormat) = afterEvaluate {
  apply<DokkaPlugin>()

  val dokkaJar by tasks.register<Jar>("dokkaJar") {
    archiveClassifier.set("javadoc")

    val dokkaTask = tasks.findByName(format.taskName) as? DokkaTask ?: tasks.withType<DokkaTask>().first()
    dependsOn(dokkaTask)
    from(dokkaTask.outputDirectory)
  }
  // Configures dokka jar to all publications
  publishing.publications.withType<MavenPublication> { artifact(dokkaJar) }
}

/**
 * Configures target repositories to publish artifacts.
 */
private fun Project.configureRepositories(repo: Array<RepoUrl>) = afterEvaluate {
  publishing.repositories {
    repo.forEach {
      it.project = project
      val url = it.url
      val maven = if (url == LocalRepo::class) mavenLocal() else maven(it.url)
      if (it.requiredCertificate) maven.credentials(PasswordCredentials::class.java)
    }
  }
}

/**
 * Configures the signings to sign artifacts to publish.
 */
private fun Project.configureSignings(
  data: PublishingData,
  releaseSigning: Boolean,
  snapshotSigning: Boolean,
) = afterEvaluate {
  if (releaseSigning || snapshotSigning) {
    apply<SigningPlugin>()

    // Signing the artifacts
    extensions.configure<SigningExtension> {
      setRequired({
        when {
          releaseSigning && snapshotSigning.not() -> data.isSnapshot.not()
          snapshotSigning && releaseSigning.not() -> data.isSnapshot
          releaseSigning && snapshotSigning -> true
          else -> false
        }
      })
      if (isRequired) sign(publishing.publications)
    }
  }
}

private fun BaseExtension.configureAllVariants(configuration: (BaseVariant) -> Unit) {
  (this as? AppExtension)?.applicationVariants?.configureEach(configuration)
    ?: (this as? LibraryExtension)?.libraryVariants?.configureEach(configuration)
    ?: (this as? TestedExtension)?.testVariants?.configureEach(configuration)
}

/**
 * Creates a new nexus staging client.
 */
private fun Project.createNexusStagingClient(baseUrl: String): NexusStagingClient {
  val credential = extensions.findByType<PublishingExtension>()?.repositories
    ?.filterIsInstance<AuthenticationSupported>()
    ?.map { it.getCredentials(PasswordCredentials::class) }
    ?.firstOrNull()

  return NexusStagingClient(
    baseUrl = "$baseUrl/service/local/",
    username = findPropertyOrEnv("sonatypeUsername")?.toString()
      ?: findPropertyOrEnv("mavenUsername")?.toString()
      ?: credential?.username
      ?: error("To close the nexus repository you must define `sonatypeUsername` in gradle.properties (Gradle Home) to verify your identity."),
    password = findPropertyOrEnv("sonatypePassword")?.toString()
      ?: findPropertyOrEnv("mavenPassword")?.toString()
      ?: credential?.password
      ?: error("To close the nexus repository you must define `sonatypePassword` in gradle.properties (Gradle Home) to verify your identity."),
  )
}

private fun Project.initSonatypeBuild() {
  // Listening to build finished and to close repositories, only need to add to root project once
  if (buildListener.not()) {
    buildListener = true
    rootProject.gradle.addBuildListener(object : BuildAdapter() {
      override fun buildFinished(result: BuildResult) {
        super.buildFinished(result)
        runBlocking {
          @Suppress("UNCHECKED_CAST")
          repositoriesToClose.forEach { (baseUrl, repositoryIds) ->
            val client = rootProject.createNexusStagingClient(baseUrl)
            repositoryIds.asFlow().map {
              val id = listOf(it)
              println("Closing $it")
              client.closeRepositories(id)
              println("Releasing $it")
              client.releaseRepositories(id, dropAfterRelease = true)
            }.retry(retries = 5) {
              // Retry after 1000 ms
              delay(1000)
              true
            }.collect()
          }
          repositoriesToClose.clear()
        }
      }
    })
  }
}

/**
 * The task used to initialize the sonatype staging repository.
 */
private fun Project.initializeSonatypeStaging(data: PublishingData, repo: SonatypeRepo) = afterEvaluate {
  tasks.withType<PublishToMavenRepository>().all {
    doFirst {
      // Don't redirect the publish of snapshot artifacts
      if (repo.isSnapshot.not()) runBlocking {
        flow {
          val client = project.createNexusStagingClient(repo.baseUrl)
          val description = publication.stagingDescription
          val profiles = client.getProfiles()
          val profile = profiles.firstOrNull { data.group == it.name }
            ?: profiles.firstOrNull { data.group.startsWith(it.name) }
            ?: profiles.firstOrNull()
            ?: return@flow

          // Check staging repository if exists in nexus
          val existing = client.getRepositories().firstOrNull {
            it.description == description && it.transitioning.not() && it.type == "open"
          }

          repo.stagingId = when {
            existing != null -> existing.repositoryId
            else -> client.createRepository(profile.id, description)
          }

          // Redirects the repository url to specific staging repository (release)
          repository.setUrl(repo.url)

          emit(Unit)
        }.retry(retries = 5) {
          // Retry after 1000 ms
          delay(1000)
          true
        }.collect()
      }

      println("Publishing to ${repository.url}")
    }
  }
}

/**
 * The task used to close and release sonatype staging repository.
 */
private fun Project.closeAndReleaseSonatypeRepository(repo: SonatypeRepo) = afterEvaluate {
  tasks.create("closeAndReleaseSonatypeRepository") {
    group = PublishingPlugin.PUBLISH_TASK_GROUP
    description = "Closes release version in the nexus repository."
    doLast {
      runBlocking {
        val client = project.createNexusStagingClient(repo.baseUrl)
        val repositoryIds = tasks.withType<PublishToMavenRepository>().mapNotNull {
          flow {
            val description = it.publication.stagingDescription
            emit(client.getRepositories()
              .firstOrNull { it.description == description }
              ?.repositoryId)
          }.retry(retries = 5) {
            // Retry after 1000 ms
            delay(1000)
            true
          }.first()
        }
        // Collect the repository ids to close
        repositoriesToClose
          .getOrPut(repo.baseUrl) { mutableSetOf() }
          .addAll(repositoryIds)
      }
    }
  }
}

private const val BUILD_LISTENER = "mavenPublish-buildListener"
private const val REPOSITORIES_TO_CLOSE = "mavenPublish-waitForCloseRepositories"

/**
 * Represents the build listener for the root project.
 */
private var Project.buildListener: Boolean
  set(value) = rootProject.extra.set(BUILD_LISTENER, value)
  get() = rootProject.extra.properties[BUILD_LISTENER] == true


/**
 * The map to represents the repositories to be closed and its url.
 */
private val Project.repositoriesToClose: MutableMap<String, MutableSet<String>>
  get() {
    if (rootProject.extra.has(REPOSITORIES_TO_CLOSE).not()) {
      rootProject.extra[REPOSITORIES_TO_CLOSE] = mutableMapOf<String, MutableSet<String>>()
    }
    @Suppress("UNCHECKED_CAST")
    return rootProject.extra[REPOSITORIES_TO_CLOSE] as MutableMap<String, MutableSet<String>>
  }

/**
 * Returns the description of staging repository.
 */
private val MavenPublication.stagingDescription: String get() = "Staging $groupId:$artifactId:$version"